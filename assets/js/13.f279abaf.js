(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{289:function(e,a,t){"use strict";t.r(a);var r=t(0),s=Object(r.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[t("a",{attrs:{href:"https://vssue.js.org",target:"_blank",rel:"noopener noreferrer"}},[e._v("Vssue"),t("OutboundLink")],1),e._v(" 是一款基于代码托管平台 Issue 评论系统的静态页面评论插件，支持 GitHub, GitLab, Bitbucket, Gitee 等多个代码托管平台，并且很容易扩展到其他平台上。")]),e._v(" "),t("p",[e._v("这篇文章对 Vssue 开发过程中遇到的问题和一些经验做个简要的记录。")]),e._v(" "),t("h2",{attrs:{id:"项目思路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#项目思路"}},[e._v("#")]),e._v(" 项目思路")]),e._v(" "),t("p",[e._v("评论是博客的一项常用功能，而静态博客则必须借助第三方工具才能实现评论功能。")]),e._v(" "),t("p",[e._v("Gitment 和 Gitalk 是两款基于 GitHub 的 Issue 系统实现的评论插件，其基本思路就是利用 GitHub 提供的 OAuth 等 API ，在前端获取 Issue 中的评论，将对应 Issue 的评论显示到当前页面，作为当前页面的评论。这两个项目存在一些特点和问题：")]),e._v(" "),t("ul",[t("li",[e._v("分别使用原生 js 和 Preact 开发。")]),e._v(" "),t("li",[e._v("仅支持 GitHub ，项目代码与 GitHub API 耦合，难以向其它平台扩展。")]),e._v(" "),t("li",[e._v("没有支持编辑、删除等常用操作。")])]),e._v(" "),t("p",[e._v("鉴于这两个项目目前均已不再积极维护，再加上目前对 Vue 比较感兴趣，我决定自己开一个类似的坑 —— Vssue 。")]),e._v(" "),t("h2",{attrs:{id:"相关工具和技术"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#相关工具和技术"}},[e._v("#")]),e._v(" 相关工具和技术")]),e._v(" "),t("h3",{attrs:{id:"lerna-与-mono-repo"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lerna-与-mono-repo"}},[e._v("#")]),e._v(" lerna 与 mono repo")]),e._v(" "),t("p",[e._v("Vssue 的主要特点就是支持多个平台，而不仅仅是 GitHub 。因此，核心思想就是将主项目代码和平台 API 解耦。")]),e._v(" "),t("p",[e._v("Vssue 的解决思路是，不同平台的 API 实现同一个 Interface ，使得平台对主项目“不透明”，主项目只需要通过调用对应方法即可获取所需要的评论相关数据。")]),e._v(" "),t("p",[e._v("在这种思路下，Vssue 使用 "),t("a",{attrs:{href:"https://github.com/lerna/lerna",target:"_blank",rel:"noopener noreferrer"}},[e._v("lerna"),t("OutboundLink")],1),e._v(" + "),t("a",{attrs:{href:"https://yarnpkg.com/lang/en/docs/workspaces/",target:"_blank",rel:"noopener noreferrer"}},[e._v("yarn workspace"),t("OutboundLink")],1),e._v(" 实现 monorepo ，即多项目仓库。Vssue 项目包含一个主项目以及不同平台 API 的子项目。")]),e._v(" "),t("p",[t("img",{attrs:{src:"/assets/img/posts/20190729-01.png",alt:"Vssue monorepo"}})]),e._v(" "),t("p",[e._v("几点 tips:")]),e._v(" "),t("ul",[t("li",[e._v("使用 yarn workspace 后，即通过 yarn 来管理整个项目的依赖关系，包括各个子项目以及彼此间的依赖。这种情况下，lerna 仅用来帮助进行版本发布相关的工作。也就是说，"),t("code",[e._v("lerna bootstrap")]),e._v(", "),t("code",[e._v("lerna add")]),e._v(" 等命令就不需要进行了。目前来看，yarn 来统一管理依赖的方式，比 npm + lerna 要更方便一些。yarn workspace + lerna 是目前 monorepo 的较优选择。")]),e._v(" "),t("li",[e._v("仓库根目录下的 "),t("code",[e._v("package.json")]),e._v(" 不参与任何要发布在 npm 的项目，一般直接设置为 "),t("code",[e._v("private: true")]),e._v("，主要是用来设置项目开发过程中的 "),t("code",[e._v("scripts")]),e._v(" 和各个项目公用的 "),t("code",[e._v("devDependencies")]),e._v("，可以把 "),t("code",[e._v("eslint")]),e._v(", "),t("code",[e._v("husky")]),e._v(", "),t("code",[e._v("lint-staged")]),e._v(", "),t("code",[e._v("typescript")]),e._v(", "),t("code",[e._v("jest")]),e._v(" 这类公用开发依赖加入根目录的 "),t("code",[e._v("package.json")]),e._v(" 中。注意在使用 yarn 的 workspace 时，需要加入 "),t("code",[e._v("-W")]),e._v(" 参数确认把依赖装在根目录，即 "),t("code",[e._v("yarn add -D -W eslint")]),e._v("。")]),e._v(" "),t("li",[e._v('lerna 管理 monorepo 时，各个 packages 有 "统一版本" 和 "独立版本" 两种模式，通过 '),t("code",[e._v("lerna.json")]),e._v(" 中的 "),t("code",[e._v('"version": "independent"')]),e._v(" 来开启独立版本模式。\n"),t("ul",[t("li",[t("p",[e._v("统一版本：各个 packages 的 "),t("strong",[e._v("最高")]),e._v(" 版本以 "),t("code",[e._v("lerna.json")]),e._v(" 中的版本号为准。每次发布新版本时，可能只更新了部分 packages 的版本号，但是每个 package 在发布时，版本号一定会更新至当前 "),t("code",[e._v("lerna.json")]),e._v(" 中的版本号。")]),e._v(" "),t("blockquote",[t("p",[e._v("举例来说：a, b, c 当前均为 1.0.0 版本，其中 b 依赖于 a，c 依赖于 b。你修改了 b 包但没有改动 a, c，此时你 "),t("code",[e._v("lerna publish")]),e._v(" 发布新版本 1.1.0，将自动检测 b 发生了修改需要更新版本，c 依赖于 b 也会一起更新版本，然后将 "),t("code",[e._v("lerna.json")]),e._v(" 中的版本号改为 1.1.0。此时 a 仍为 1.0.0 版本，而 b 和 c 为 1.1.0 版本。下一次你对 a, b, c 均有改动，发布 1.1.1 版本时，a 将直接跳过 1.1.0 版本，将版本号更新至 1.1.1。此时 a, b, c 同时发布为 1.1.1 版本。")])]),e._v(" "),t("blockquote",[t("p",[e._v("统一版本的例子有： 7.0 版本后的 "),t("a",{attrs:{href:"https://github.com/babel/babel",target:"_blank",rel:"noopener noreferrer"}},[e._v("babel"),t("OutboundLink")],1),e._v("，3.0 版本后的 "),t("a",{attrs:{href:"https://github.com/vuejs/vue-cli",target:"_blank",rel:"noopener noreferrer"}},[e._v("vue-cli"),t("OutboundLink")],1),e._v(" ，"),t("a",{attrs:{href:"https://github.com/lerna/lerna",target:"_blank",rel:"noopener noreferrer"}},[e._v("lerna"),t("OutboundLink")],1),e._v(" 本身 等等。")])])]),e._v(" "),t("li",[t("p",[e._v("独立版本：顾名思义，各个 packages 的版本互相独立，与 "),t("code",[e._v("lerna.json")]),e._v(" 无关，所以就在 "),t("code",[e._v("lerna.json")]),e._v(" 中设置 "),t("code",[e._v('"version": "independent"')]),e._v(" 开启。这种模式下，每次发布版本会在 commit message 中列出所有发布的 package 及对应版本号，并且 git tag 也会分别打上所有的 "),t("code",[e._v("package-name@version")]),e._v("。")]),e._v(" "),t("blockquote",[t("p",[e._v("举例来说：你通过 "),t("code",[e._v("lerna publish")]),e._v(" 发布 a 的 1.2.3 版本和 b 的 2.3.4 版本，会打上两个 git tag："),t("code",[e._v("a@1.2.3")]),e._v(", "),t("code",[e._v("b@2.3.4")]),e._v("，并且默认的 commit message 会是：")])]),e._v(" "),t("div",{staticClass:"language-md extra-class"},[t("pre",{pre:!0,attrs:{class:"language-md"}},[t("code",[e._v("Publish\n"),t("span",{pre:!0,attrs:{class:"token list punctuation"}},[e._v("-")]),e._v(" a@1.2.3\n"),t("span",{pre:!0,attrs:{class:"token list punctuation"}},[e._v("-")]),e._v(" b@2.3.4\n")])])]),t("blockquote",[t("p",[e._v("独立版本的例子有： "),t("a",{attrs:{href:"https://github.com/saberland/saber",target:"_blank",rel:"noopener noreferrer"}},[e._v("saber"),t("OutboundLink")],1),e._v(" 等等。")])])])])])]),e._v(" "),t("h3",{attrs:{id:"typescript-与-vue"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#typescript-与-vue"}},[e._v("#")]),e._v(" typescript 与 vue")]),e._v(" "),t("h3",{attrs:{id:"vue-cli-与-rollup"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-cli-与-rollup"}},[e._v("#")]),e._v(" vue-cli 与 rollup")])])}),[],!1,null,null,null);a.default=s.exports}}]);